# LayerZero

---

## 1. 개요

LayerZero는 서로 다른 블록체인 간 데이터를 **안전하고 신뢰성 있게 전달**하기 위한 크로스체인 메시징 프로토콜이다.

이 프로토콜의 목적은 각 블록체인의 독립성을 유지하면서도 체인 간 메시지 교환과 로직 실행을 가능하게 한다.

---

## 2. 아키텍처 구성

LayerZero V2는 다음 네 가지 구성요소로 이루어진다.

| 구성요소                                 | 역할                                                |
| ---------------------------------------- | --------------------------------------------------- |
| **Endpoint Contract**                    | 각 체인의 메시지 입출구 (송수신 담당)               |
| **MessageLib (ULN302)**                  | 메시지 인코딩 및 검증 로직 수행                     |
| **DVN (Decentralized Verifier Network)** | 메시지의 무결성 검증 수행                           |
| **Executor**                             | 검증 완료된 메시지를 실행하는 주체 (permissionless) |

이 구조는 **검증(Verification)** 과 **실행(Execution)** 단계를 분리하여 보안성과 확장성을 높인다.

---

## 3. 메시징 과정

LayerZero의 메시징은 다음 세 단계로 이루어진다:

1. **송신 (Send)**
2. **검증 (Verify)**
3. **실행 (Execute)**

---

### STEP 1. 송신 단계 (Source Chain)

OApp(Omnichain Application)은 `_lzSend()`를 통해 메시지를 전송한다.

이 함수는 수수료 계산, 패킷 생성, 그리고 Endpoint의 `send()` 호출을 수행한다.

```solidity
// OAppSender.sol
function _lzSend(
    uint32 _dstEid,           // 목적지 체인 ID
    bytes memory _message,    // 전송할 데이터
    bytes memory _options,    // 실행 옵션 (gas limit 등)
    MessagingFee memory _fee, // 수수료 정보
    address _refundAddress    // 초과 수수료 반환 주소
) internal virtual returns (MessagingReceipt memory receipt) {
    uint256 messageValue = _payNative(_fee.nativeFee);
    if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);

    return endpoint.send{ value: messageValue }(
        MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),
        _refundAddress
    );
}
```

**핵심 동작:**

- 사용자는 `_lzSend()`를 직접 호출하지 않고, OApp의 public 함수(`sendMessage` 등)에서 내부적으로 호출한다.
- 메시지에 nonce 와 GUID(고유 ID) 가 자동 부여된다.
- Endpoint는 **`PacketSent` 이벤트**를 발생시켜 DVN이 이를 감지한다.

---

### STEP 2. 검증 단계 (Cross-chain Verification)

DVN은 오프체인에서 메시지의 `payload hash`를 검증한 뒤, 모든 필수 DVN(required)과 임계값을 만족하는 선택 DVN(optional)이 서명하면 온체인으로 결과를 커밋한다.

```solidity
// EndpointV2.sol
function verify(
    Origin calldata _origin,
    address _receiver,
    bytes32 _payloadHash
) external {
    if (!isValidReceiveLibrary(_receiver, _origin.srcEid, msg.sender))
        revert Errors.LZ_InvalidReceiveLibrary();

    _inbound(_receiver, _origin.srcEid, _origin.sender, _origin.nonce, _payloadHash);
    emit PacketVerified(_origin, _receiver, _payloadHash);
}
```

**핵심 동작:**

- DVN이 검증 완료 후 `verify()` 호출 → 메시지 `inbound` 큐로 이동
- 검증이 끝난 패킷은 이제 "실행 대기 상태"가 된다
- 검증은 오프체인에서 수행되고, 결과만 온체인으로 기록된다

---

### STEP 3. 실행 단계 (Destination Chain)

Executor가 검증 완료된 메시지를 가져와 `lzReceive()`를 호출한다.

이 함수는 최종적으로 OApp의 `_lzReceive()`를 실행시킨다.

```solidity
// EndpointV2.sol
function lzReceive(
    Origin calldata _origin,
    address _receiver,
    bytes32 _guid,
    bytes calldata _message,
    bytes calldata _extraData
) external payable {
    _clearPayload(_receiver, _origin.srcEid, _origin.sender, _origin.nonce,
                  abi.encodePacked(_guid, _message));

    ILayerZeroReceiver(_receiver).lzReceive{ value: msg.value }(
        _origin, _guid, _message, msg.sender, _extraData
    );

    emit PacketDelivered(_origin, _receiver);
}
```

**핵심 동작:**

- Executor는 **permissionless** → 누구나 메시지 실행 가능
- `payload`를 먼저 삭제하여 재진입 공격 방지
- `_extraData`는 신뢰할 수 없는 입력이므로 OApp에서 별도 검증 필요

---

## 4. DVN (Decentralized Verifier Network)

DVN은 메시지의 무결성을 보장하는 **분산 검증 네트워크**이다.

**구성 예시:**

```solidity
struct UlnConfig {
    uint64 confirmations;           // 블록 확정 수
    uint8 requiredDVNCount;         // 필수 DVN 개수
    uint8 optionalDVNCount;         // 선택 DVN 개수
    uint8 optionalDVNThreshold;     // 선택 DVN 중 필요한 최소 수
    address[] requiredDVNs;         // 필수 DVN 주소 배열
    address[] optionalDVNs;         // 선택 DVN 주소 배열
}
```

**특징:**

- 필수 DVN이 모두 승인 + 선택 DVN의 threshold 충족 시 검증 성공
- 각 DVN은 독립적으로 작동 (Light Client, Oracle, ZK 등 다양한 방식 사용 가능)
- 완전한 라이트 클라이언트는 아니지만, **Pragmatic Decentralization**을 지향

---

## 5. Executor

Executor는 DVN 검증 이후의 메시지를 실제로 실행하는 역할을 담당한다.

**특징:**

- **Permissionless** – 누구나 실행 가능
- **비동기 처리** – 검증 완료 후 실행
- **Non-blocking** – 하나의 실패가 전체 큐를 막지 않음
- **가스 수익 구조** – 남는 수수료는 Executor 이익으로 귀속

---

## 6. OFT (Omnichain Fungible Token)

OFT는 LayerZero가 제안한 크로스체인 토큰 표준으로, 기존의 "Lock & Mint" 대신 "Burn & Mint" 메커니즘을 사용한다.

| 구분      | 기존 브릿지                                        | OFT                                               |
| --------- | -------------------------------------------------- | ------------------------------------------------- |
| 메커니즘  | 소스 체인에서 토큰 락 → 대상 체인에서 wrapped 민트 | 소스 체인에서 소각 → 대상 체인에서 동일 토큰 민트 |
| 공급량    | 체인별로 별도                                      | 전체 체인에서 일관성 유지                         |
| 토큰 형태 | wrapped/original 혼재                              | 모든 체인에서 동일                                |
| 유동성    | 분산                                               | 통합                                              |

**핵심 원리:**

- 소스 체인 `_debit()` → 토큰 소각
- 목적지 체인 `_credit()` → 동일 수량 민트
- 전체 공급량은 항상 일정하게 유지

---

## 7. 보안 모델

LayerZero의 보안은 검증(Verification) 과 실행(Execution) 의 완전한 분리에 기반한다.

| 위협 요소     | 대응 방식                          |
| ------------- | ---------------------------------- |
| 메시지 위조   | DVN 다중 검증 및 payload hash 비교 |
| 재진입 공격   | payload 삭제 후 실행               |
| 실행자 조작   | 검증 완료된 메시지만 실행 가능     |
| 네트워크 장애 | DVN threshold 충족 시 자동 복구    |

---

## 참고 자료

- [LayerZero Docs](https://docs.layerzero.network/)
- [LayerZero GitHub (v2)](https://github.com/LayerZero-Labs/LayerZero-v2)
- [OFT 표준 문서](https://docs.layerzero.network/contracts/oft)
