### LayerZero란?
상호운용성 프로토콜이다. 레이어제로를 이용해 서로 독립적인 블록체인들이 데이터를 안전하게 교환하고, 자산을 이동시킬 수 있다. 
### LayerZero V2 프로토콜 아키텍처
LayerZero는 기존의 Interface Layer, Verification Layer, Execution Layer을 하나로 결합했던 방식에서 벗어나 다섯 개의 독립적인 계층으로 분리했다. 

1. Business Logic (OApp) - 비즈니스 로직만 처리하는 애플리케이션 계층
2. Protocol Interface (Endpoint) - 변하지 않는 엔드포인트 인터페이스
3. Configurable Libraries - 경로별로 설정 가능한 메시지 라이브러리
4. Verification - DVN들을 통한 다중 검증
5. Execution - 비허가형 메시지 실행 계층 

레이어제로는 모든 체인에 공통된 엔드포인트를 배포하기 때문에, 체인이 늘어날 때마다 별도의 브릿지를 만들지 않고도 엔드포인트를 통해 모든 체인과 연결할 수 있다. 
#### Business Logic Interface, OApp
- 크로스체인 메시지를 송수신하는 스마트 컨트랙트 표준
- 직접 endpoint.send()나 endpoint.lzReceive()를 호출하지 않고 _lzSend()와 _lzReceive()를 사용한다. 
#### Protocol Interface, Endpoint
- 엔드포인트는 메시지를 전송하고 수신하는 역할을 한다. 
- 각 체인은 하나의 LayerZero Endpoint 컨트랙트를 가지며, 이를 통해 다른 모든 체인의 엔드포인트와 통신할 수 있다. 
- OApp들은 Channel을 이용해서 통신한다. 채널은 송신 컨트랙트 (Sender Contract / Source OApp), 소스 엔드포인트 ID (Source Endpoint ID), 목적지 엔드포인트 ID (Destination Endpoint ID), 수신 컨트랙트 (Receiver Contract / Destination OApp) 이렇게 4가지 요소로 정의된다.
- 각 채널 내에서는 논스를 통해 메시지 순서가 유지되며, 메시지가 한 번만 전달되도록 한다.
#### Configurable Message Libraries
- 체인 간 메시지를 오프체인으로 전송하고, 다시 온체인으로 전달하는 규칙 집합(on-chain ruleset)이다.
- 이 라이브러리는 메시지 처리, 검증, 실행 조정을 정의하며, 엔드포인트 간 인터페이스는 유지하면서도 경로별로 동작을 커스터마이즈할 수 있다.
#### DVNs (Decentralized Verifier Networks)
- 검증 네트워크로 ZK Proof, Light Client, Committee, Middlechain 등 다양한 검증 방식을 독립적으로 운영하는 서비스이다. 
- 각 DVN은 서로 다른 검증 로직을 가지며, 채널마다 다른 DVN 세트를 설정할 수 있다. 
- 임계값을 설정해 여러 DVN을 이용해서 X-of-Y-of-N 형태의 다중 검증을 진행한다. 
#### Executor
- DVN을 통해 검증된 메시지를 목적지 체인에 전달한다. 
- 누구나 참여할 수 있으며, 속도와 수수료를 통해 경쟁한다. 

### 트랜잭션 실행 과정
#### 소스 체인에서의 메시지 전송 (Message Dispatch on the Source Chain)
소스 블록체인의 스마트 컨트랙트가 엔드포인트의 엔트리 함수를 호출하여 프로세스를 시작한다.
이 호출에는 임의의 메시지 페이로드, 목적지 엔드포인트 세부정보, 수신 컨트랙트 주소가 포함된다.
이후 엔드포인트는 구성 가능한(Message Library)를 사용하여 송신자 컨트랙트의 설정에 따라 표준화된 메시지 패킷(Message Packet)을 생성한다.
```
// SPDX-License-Identifier: MIT
import {OApp, MessagingFee, Origin} from "@layerzerolabs/oapp-evm/contracts/oapp/OApp.sol";
import {OptionsBuilder} from "@layerzerolabs/oapp-evm/contracts/oapp/libs/OptionsBuilder.sol";

contract MyOmnichainApp is OApp {
    using OptionsBuilder for bytes;

    constructor(address endpoint) OApp(endpoint, msg.sender) {}

	function sendMessage(uint32 dstEid, bytes memory message) external payable {
        bytes memory options = OptionsBuilder.newOptions()
            .addExecutorLzReceiveOption(200_000, 0);

        // 순서 보장이 필요한 경우:
        // options = options.addExecutorOrderedExecutionOption();

        _lzSend(
            dstEid,
            message,
            combineOptions(dstEid, SEND, options),
            MessagingFee(msg.value, 0),
            payable(msg.sender)
        );
        // 메시지 send 함수를 호출하면 엔드포인트의 _lzSend()함수가 호출된다. 
        //_lzSend() 함수 내에서 Endpoint.send() 함수가 호출된다. 
    }
}
```
LayerZero-v2/packages/layerzero-v2/evm/oapp/contracts/oapp
/OAppSender.sol
```
function _lzSend(
        uint32 _dstEid,
        bytes memory _message,
        bytes memory _options,
        MessagingFee memory _fee,
        address _refundAddress
    ) internal virtual returns (MessagingReceipt memory receipt) {
        // @dev Push corresponding fees to the endpoint, any excess is sent back to the _refundAddress from the endpoint.
        uint256 messageValue = _payNative(_fee.nativeFee);
        if (_fee.lzTokenFee > 0) _payLzToken(_fee.lzTokenFee);

        return
            // solhint-disable-next-line check-send-result
            // _lzSend() 내에서 endpoint.send()를 호출한다.
            endpoint.send{ value: messageValue }(
                MessagingParams(_dstEid, _getPeerOrRevert(_dstEid), _message, _options, _fee.lzTokenFee > 0),
                _refundAddress
            );
    }

```
LayerZero-v2/packages/layerzero-v2/evm/protocol/contracts
/EndpointV2.sol

```
function _send(
        address _sender,
        MessagingParams calldata _params
    ) internal returns (MessagingReceipt memory, address) {
        // get the correct outbound nonce
        uint64 latestNonce = _outbound(_sender, _params.dstEid, _params.receiver);

        // construct the packet with a GUID
        // 패킷 생성
        Packet memory packet = Packet({
            nonce: latestNonce,
            srcEid: eid,
            sender: _sender,
            dstEid: _params.dstEid,
            receiver: _params.receiver,
            guid: GUID.generate(latestNonce, eid, _sender, _params.dstEid, _params.receiver),
            message: _params.message
        });

        // 메시지 라이브러리
        address _sendLibrary = getSendLibrary(_sender, _params.dstEid);

        // messageLib always returns encodedPacket with guid
        (MessagingFee memory fee, bytes memory encodedPacket) = ISendLib(_sendLibrary).send(
            packet,
            _params.options,
            _params.payInLzToken
        );

        // Emit packet information for DVNs, Executors, and any other offchain infrastructure to only listen
        // for this one event to perform their actions.
        emit PacketSent(encodedPacket, _params.options, _sendLibrary);
        // 생성된 패킷은 이벤트로 발생된다.

        return (MessagingReceipt(packet.guid, latestNonce, fee), _sendLibrary);
    }
```
#### 보안 채널 설정 (Establishing a Secure Channel)
생성된 메시지 패킷은 소스 엔드포인트에 의해 이벤트로 발생(emitted)한다.
이 패킷에는 소스 및 목적지 엔드포인트 ID, 송신자 및 수신자 주소, 메시지 페이로드 등이 포함되어 있으며, 이 정보들이 합쳐져 고유한 메시징 채널을 정의한다.
#### 검증 및 논스 관리 (Verification and Nonce Management)
구성된 보안 스택(Security Stack, DVNs)이 소스 체인에서 발생한 PacketSent 이벤트를 감지하고, 해당 패킷의 페이로드 해시를 목적지 체인의 메시지 라이브러리로 전달한다.
설정된 X of Y of N DVN 검증 임계값이 충족되면, 메시지 패킷은 검증 완료로 표시되고 목적지 채널에 커밋되어 정확히 한 번의 전달(Exactly-once delivery)이 보장된다.
#### 목적지 체인에서의 메시지 실행 (Message Execution on the Destination Chain)
Executor와 같은 권한 있는 스마트 컨트랙트가 엔드포인트의 lzReceive 함수를 호출하여 검증된 메시지의 실행을 트리거한다.
이 호출은 메시지 페이로드를 수신 컨트랙트에 전달하며, 수신 컨트랙트는 전달된 데이터를 기반으로 정의된 로직을 실행한다.